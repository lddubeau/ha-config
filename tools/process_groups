#!/usr/bin/env python3

import datetime
import os
import os.path
import yaml
from collections.abc import Iterable

indir = "src"
outdir = "out"

# https://stackoverflow.com/a/39681672
class FixedDumper(yaml.Dumper):

    def increase_indent(self, flow=False, indentless=False):
        return super(FixedDumper, self).increase_indent(flow, False)


def dump_yaml(out_path, content):
    with open(out_path, "w") as outf:
        outf.write(f"""\
# This file was generated. Do not edit by hand.
# Generated at {datetime.datetime.now()}.
""")
        yaml.dump(content, outf, default_flow_style=False, Dumper=FixedDumper)

# https://stackoverflow.com/a/52621703
yaml.add_representer(dict,
                     lambda self, data: yaml.representer.SafeRepresenter
                     .represent_dict(self, data.items()))

def flatten(it):
    for x in it:
        if isinstance(x, Iterable):
            for y in x:
                yield y
        else:
            yield x

def flatten_constructor(loader, node):
    return list(flatten(loader.construct_sequence(node)))

yaml.add_constructor("!flatten", flatten_constructor)

class Noop(object):

    def __init__(self, tag, value):
        self.tag = tag
        self.value = value

    def __repr__(self):
        return f"{self.tag} {self.value}"

yaml.add_constructor("!include", lambda loader,
                     node: Noop(node.tag, node.value))

yaml.add_representer(Noop, lambda dumper,
                     obj: dumper.represent_scalar(obj.tag, obj.value))

def make_room_view(title, path, **kwargs):
    return dict(title=title,
                path=path,
                background="black",
                theme="slate",
                # Drop values that are None. It would result in a null value
                # in the yaml, but we have no use for it.
                **{k: v for (k, v) in kwargs.items() if v is not None})

def make_entity_card(entity):
    domain = entity["entity"].split(".", 1)[0]

    try:
        entity_type = {
            "light": "light",
            "media_player": "media-control",
            "sensor": "sensor",
        }[domain]
    except KeyError:
        entity_type = None

    return dict(type=entity_type,
                entity=entity["entity"],
                name=entity["name"])

def read_groups():
    groups = {}
    with os.scandir(os.path.join(indir, "groups")) as it:
        for group in it:
            with open(group.path, "r") as inf:
                group_yaml_name = os.path.splitext(group.name)[0]
                data = yaml.load(inf)

                # Normalize entities to objects.
                data["entities"] = [dict(entity=entity) if
                                    isinstance(entity, str) else entity for
                                    entity in data["entities"]] \
                    if "entities" in data else []

                groups[group_yaml_name] = data
    return groups

def process_groups_into_rooms():
    rooms = {}
    orders = set()
    for (name, group) in read_groups().items():
        # Each group in the input is converted to a group in the output.
        dump_yaml(os.path.join(outdir, "groups", f"{name}.yaml"),
                  dict(name=group["name"],
                       entities=[entity["entity"] for entity in
                                 group["entities"]]))

        if group.get("type", None) == "room":
            order = group["order"]
            if order in orders:
                raise Exception(f"room order {order} seen more than once")
            orders.add(order)
            # Create one view per room.
            dump_yaml(os.path.join(outdir, "views", f"{name}.yaml"),
                      make_room_view(group["name"],
                                     name,
                                     icon=group.get("icon", None),
                                     cards=[make_entity_card(entity)
                                            for entity in group["entities"]]))

            # And remember which groups are rooms
            rooms[name] = group

    return rooms

def create_cloud_yaml(rooms):
    #
    # Create a cloud.yaml file for Google that tells where each entity is
    # located
    #

    # We don't put in this list those devices that Google already knows about.
    excluded_from_cloud = set([
        "media_player.office_speaker",
        "media_player.kitchen_speaker",
        "media_player.google_mini_er",
        "media_player.living_room_chromecast",
        "media_player.living_room_home",
        "media_player.google_mini_mbr",
        "media_player.craft_room_speaker"])

    entity_id_to_cloud_config = {}

    for room in rooms.values():
        for entity in room["entities"]:
            entity_id = entity["entity"]
            if entity_id not in excluded_from_cloud:
                entity_id_to_cloud_config[entity_id] = dict(room=room["name"])

    dump_yaml(
        os.path.join(outdir, "cloud.yaml"),
        dict(google_actions=dict(entity_config=entity_id_to_cloud_config)))


def process_file(path):
    with open(os.path.join(indir, path), "r") as inf:
        dump_yaml(os.path.join(outdir, path), yaml.load(inf))

def main():
    try:
        os.mkdir(os.path.join(outdir, "groups"))
    except:
        pass

    try:
        os.mkdir(os.path.join(outdir, "views"))
    except:
        pass

    rooms = process_groups_into_rooms()

    # We also create a "rooms.yaml" group
    dump_yaml(os.path.join(outdir, "groups", "rooms.yaml"),
              dict(name="Rooms",
                   entities=[f"group.{name}" for name in rooms.keys()]))

    def rooms_constructor(loader, node):
        return [dict(title=room["name"],
                     type="glance",
                     entities=room["entities"]) for room in
                sorted(rooms.values(), key=lambda x: x["order"])]

    yaml.add_constructor(u"!rooms", rooms_constructor)

    def room_list_constructor(loader, node):
        return [Noop("!include", os.path.join('views', 'rooms.yaml'))] + \
            [Noop("!include", f"{os.path.join('views', name)}.yaml")
             for (name, room) in sorted(rooms.items(),
                                        key=lambda x: x[1]["order"])]

    yaml.add_constructor(u'!room_list', room_list_constructor)

    process_file(os.path.join("views", "rooms.yaml"))
    process_file("ui-lovelace.yaml")
    create_cloud_yaml(rooms)

main()
