#!/usr/bin/env python3

import datetime
import os
import os.path
import yaml

indir = "src"
outdir = "out"

# https://stackoverflow.com/a/39681672
class FixedDumper(yaml.Dumper):

    def increase_indent(self, flow=False, indentless=False):
        return super(FixedDumper, self).increase_indent(flow, False)


def dump_yaml(out_path, content):
    with open(out_path, "w") as outf:
        outf.write(f"""\
# This file was generated. Do not edit by hand.
# Generated at {datetime.datetime.now()}.
""")
        yaml.dump(content, outf, default_flow_style=False, Dumper=FixedDumper)

# https://stackoverflow.com/a/52621703
yaml.add_representer(dict,
                     lambda self, data: yaml.representer.SafeRepresenter
                     .represent_dict(self, data.items()))

def flatten(it):
    for x in it:
        if isinstance(x, list):
            yield from x
        else:
            yield x

def flatten_constructor(loader, node):
    return list(flatten(loader.construct_sequence(node)))

yaml.add_constructor("!flatten", flatten_constructor)

class Noop(object):

    def __init__(self, tag, value):
        self.tag = tag
        self.value = value

    def __repr__(self):
        return f"{self.tag} {self.value}"

yaml.add_constructor("!include", lambda loader,
                     node: Noop(node.tag, node.value))

yaml.add_representer(Noop, lambda dumper,
                     obj: dumper.represent_scalar(obj.tag, obj.value))

def make_room_view(title, path, **kwargs):
    return dict(title=title,
                path=path,
                background="black",
                theme="slate",
                # Drop values that are None. It would result in a null value
                # in the yaml, but we have no use for it.
                **{k: v for (k, v) in kwargs.items() if v is not None})

def make_entity_card(entity):
    domain = entity["entity"].split(".", 1)[0]

    try:
        entity_type = {
            "light": "light",
            "media_player": "media-control",
            "sensor": "sensor",
            "script": "entity-button",
            "switch": "entity-button",
            "input_boolean": "entity-button",
        }[domain]
    except KeyError:
        entity_type = None

    return dict(type=entity_type,
                entity=entity["entity"],
                name=entity.get("name"))

def read_groups():
    groups = {}
    with os.scandir(os.path.join(indir, "groups")) as it:
        for group in it:
            with open(group.path, "r") as inf:
                group_yaml_name = os.path.splitext(group.name)[0]
                data = yaml.load(inf)

                # Normalize entities to objects.
                data["entities"] = [dict(entity=entity) if
                                    isinstance(entity, str) else entity for
                                    entity in data["entities"]] \
                    if "entities" in data else []

                groups[group_yaml_name] = data
    return groups

def process_groups_into_rooms(room_order):
    rooms = {}
    all_entities = []
    for (name, group) in read_groups().items():
        # Each group in the input is converted to a group in the output.
        dump_yaml(os.path.join(outdir, "groups", f"{name}.yaml"),
                  dict(name=group["name"],
                       entities=[entity["entity"] for entity in
                                 group["entities"]]))

        if group.get("type", None) == "room":
            if name not in room_order:
                raise Exception("room not listed in room_order.yaml: " + name)
            # Create one view per room.
            entities = group["entities"]
            all_entities += entities
            dump_yaml(os.path.join(outdir, "views", f"{name}.yaml"),
                      make_room_view(group["name"],
                                     name,
                                     icon=group.get("icon", None),
                                     cards=[make_entity_card(entity)
                                            for entity in group["entities"]]))

            # And remember which groups are rooms
            rooms[name] = group

    return (rooms, all_entities)

def create_customize(entities):
    #
    # Create a customized.yaml file that gives a friendly name for each entity.
    #

    customizations = {}

    for entity in entities:
        if "name" in entity:
            customizations[entity["entity"]] = dict(
                friendly_name=entity["name"])

    dump_yaml(os.path.join(outdir, "customize.yaml"), customizations)

def create_cloud_yaml(rooms):
    #
    # Create a cloud.yaml file for Google that tells where each entity is
    # located
    #

    # We don't put in this list those devices that Google already knows about.
    excluded_from_cloud = set([
        "media_player.office_speaker",
        "media_player.kitchen_speaker",
        "media_player.google_mini_er",
        "media_player.living_room_chromecast",
        "media_player.living_room_home",
        "media_player.google_mini_mbr",
        "media_player.craft_room_speaker"])

    entity_id_to_cloud_config = {}

    for room in rooms.values():
        for entity in room["entities"]:
            entity_id = entity["entity"]
            if entity_id not in excluded_from_cloud:
                entity_id_to_cloud_config[entity_id] = dict(room=room["name"])

    dump_yaml(
        os.path.join(outdir, "cloud.yaml"),
        dict(google_actions=dict(entity_config=entity_id_to_cloud_config)))


def process_file(path):
    with open(os.path.join(indir, path), "r") as inf:
        dump_yaml(os.path.join(outdir, path), yaml.load(inf))


def read_room_order():
    with open(os.path.join(indir, "room_order.yaml")) as inf:
        return yaml.load(inf)

def main():
    try:
        os.mkdir(os.path.join(outdir, "groups"))
    except:
        pass

    try:
        os.mkdir(os.path.join(outdir, "views"))
    except:
        pass

    room_order = read_room_order()
    (rooms, entities) = process_groups_into_rooms(room_order)
    sorted_rooms = sorted(rooms.items(), key=lambda x: room_order.index(x[0]))

    # We also create a "rooms.yaml" group
    dump_yaml(os.path.join(outdir, "groups", "rooms.yaml"),
              dict(name="Rooms",
                   entities=[f"group.{name}" for name in rooms.keys()]))

    def rooms_constructor(loader, node):
        return [dict(title=room["name"],
                     type="glance",
                     entities=room["entities"]) for (_, room) in sorted_rooms]

    yaml.add_constructor(u"!rooms", rooms_constructor)

    def room_list_constructor(loader, node):
        return [Noop("!include", os.path.join('views', 'rooms.yaml'))] + \
            [Noop("!include", f"{os.path.join('views', name)}.yaml")
             for (name, _) in sorted_rooms]

    yaml.add_constructor(u'!room_list', room_list_constructor)

    process_file(os.path.join("views", "rooms.yaml"))
    process_file("ui-lovelace.yaml")
    create_cloud_yaml(rooms)
    create_customize(entities)

main()
